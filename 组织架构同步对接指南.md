# HiAgent 组织架构同步对接指南

## 1. 整体架构流程

```
客户OA系统 ---(1. 写入临时表)---> PG临时数据库(tmp db)
                                      ↑
                            (2. 定时任务读取临时表)
                                      |
iam-adapter ---------(3. 定时任务写入)--------> iam db
```

**流程说明：**
1. 客户自行开发同步脚本，将三方OA系统的组织架构数据写入临时数据库
2. iam-adapter 通过定时任务读取临时表数据
3. iam-adapter 将数据同步写入 IAM 数据库，完成与 HiAgent 的对接

---

## 2. 在 PG 临时数据库中创建临时表

需要创建以下三张表：

### 2.1 临时用户表 (tmp_user)

```sql
CREATE TABLE IF NOT EXISTS tmp_user (
    id              VARCHAR(64)     NOT NULL PRIMARY KEY,  -- 直接用三方系统的用户ID
    created_time    TIMESTAMP       DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_time    TIMESTAMP       DEFAULT CURRENT_TIMESTAMP NOT NULL,
    tenant_id       VARCHAR(64)     DEFAULT '0' NOT NULL,  -- 从HiAgent获取租户ID
    user_name       VARCHAR(128)    DEFAULT '' NOT NULL,   -- 用户名(唯一)
    description     VARCHAR(255)    DEFAULT '' NOT NULL,
    display_name    VARCHAR(255)    DEFAULT '' NOT NULL,   -- 显示名称
    email           VARCHAR(256)    DEFAULT '' NOT NULL,
    mobile          VARCHAR(256)    DEFAULT '' NOT NULL,
    source          VARCHAR(16)     DEFAULT 'CAS' NOT NULL,-- 用户来源
    status          SMALLINT        DEFAULT 1 NOT NULL,    -- 1:active 0:inactive
    is_deleted      SMALLINT        DEFAULT 0 NOT NULL,    -- 0:否 1:是
    CONSTRAINT uk_tenant_id_user_name UNIQUE (tenant_id, user_name)
);
```

### 2.2 临时组织表 (tmp_organization)

```sql
CREATE TABLE IF NOT EXISTS tmp_organization (
    id              VARCHAR(64)     NOT NULL PRIMARY KEY,  -- 直接用三方系统的组织ID
    created_time    TIMESTAMP       DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_time    TIMESTAMP       DEFAULT CURRENT_TIMESTAMP NOT NULL,
    name            VARCHAR(128)    DEFAULT '' NOT NULL,   -- 组织名称
    org_code        VARCHAR(128)    DEFAULT '' NOT NULL,   -- 组织编码(唯一)
    tenant_id       VARCHAR(64)     DEFAULT '' NOT NULL,   -- 租户ID
    pid             VARCHAR(64)     DEFAULT '' NOT NULL,   -- 父节点ID(根节点为空)
    is_deleted      SMALLINT        DEFAULT 0 NOT NULL,
    CONSTRAINT uk_tenant_id_org_code UNIQUE (tenant_id, org_code)
);
```

### 2.3 临时用户组织关系表 (tmp_org_user_relation)

```sql
CREATE TABLE IF NOT EXISTS tmp_org_user_relation (
    id              VARCHAR(64)     NOT NULL PRIMARY KEY,
    created_time    TIMESTAMP       DEFAULT CURRENT_TIMESTAMP NOT NULL,
    updated_time    TIMESTAMP       DEFAULT CURRENT_TIMESTAMP NOT NULL,
    org_id          VARCHAR(64)     NOT NULL,              -- 组织ID
    user_id         VARCHAR(64)     DEFAULT '' NOT NULL,   -- 用户ID
    tenant_id       VARCHAR(64)     DEFAULT '' NOT NULL    -- 租户ID
);
```

---

## 3. 字段说明

### 3.1 tmp_user 字段说明

| 字段 | 必填 | 说明 |
|------|------|------|
| id | 是 | 唯一ID，直接用三方系统中的用户ID |
| user_name | 是 | 用户名（登录账号），租户内唯一 |
| tenant_id | 是 | 租户ID，从HiAgent环境获取 |
| display_name | 是 | 显示名称/昵称 |
| source | 是 | 用户来源，默认填 `CAS` |
| status | 是 | 用户状态，1=启用，0=禁用 |
| is_deleted | 是 | 是否删除，0=否，1=是 |
| email | 否 | 邮箱 |
| mobile | 否 | 手机号 |

### 3.2 tmp_organization 字段说明

| 字段 | 必填 | 说明 |
|------|------|------|
| id | 是 | 唯一ID，直接用三方系统中的组织ID |
| name | 是 | 组织名称 |
| org_code | 是 | 组织编码，租户内唯一 |
| tenant_id | 是 | 租户ID，从HiAgent环境获取 |
| pid | 是 | 父节点ID，根节点填空字符串 `''` |
| is_deleted | 是 | 是否删除，0=否，1=是 |

### 3.3 tmp_org_user_relation 字段说明

| 字段 | 必填 | 说明 |
|------|------|------|
| id | 否 | 唯一ID，可用UUID生成或数据库自增 |
| org_id | 是 | 组织ID，对应 tmp_organization.id |
| user_id | 是 | 用户ID，对应 tmp_user.id |
| tenant_id | 是 | 租户ID |

---

## 4. 编写数据同步脚本（三方系统 → 临时表）

以下是 Python 示例代码，演示如何从三方OA系统同步数据到临时表：

```python
import psycopg2
import uuid
from datetime import datetime

# ============================================
# 配置信息
# ============================================
TENANT_ID = "your_tenant_id"  # 从HiAgent环境获取

# 三方系统数据库连接
SOURCE_DB_CONFIG = {
    "host": "third-party-db-host",
    "port": 5432,
    "database": "oa_system",
    "user": "oa_user",
    "password": "oa_password"
}

# 临时数据库连接（你申请的PG）
TMP_DB_CONFIG = {
    "host": "tmp-pg-host",
    "port": 5432,
    "database": "tmp_sync_db",
    "user": "tmp_user",
    "password": "tmp_password"
}


# ============================================
# 同步组织架构
# ============================================
def sync_organizations():
    """同步组织架构"""
    source_conn = psycopg2.connect(**SOURCE_DB_CONFIG)
    tmp_conn = psycopg2.connect(**TMP_DB_CONFIG)

    try:
        source_cur = source_conn.cursor()
        tmp_cur = tmp_conn.cursor()

        # 从三方系统查询组织数据
        source_cur.execute("""
            SELECT
                dept_id,           -- 部门ID
                dept_name,         -- 部门名称
                dept_code,         -- 部门编码
                parent_dept_id     -- 父部门ID
            FROM oa_department
            WHERE status = 1
        """)

        orgs = source_cur.fetchall()

        for org in orgs:
            dept_id, dept_name, dept_code, parent_id = org

            # 插入或更新临时组织表
            tmp_cur.execute("""
                INSERT INTO tmp_organization
                    (id, name, org_code, tenant_id, pid, is_deleted, updated_time)
                VALUES (%s, %s, %s, %s, %s, 0, NOW())
                ON CONFLICT (tenant_id, org_code)
                DO UPDATE SET
                    name = EXCLUDED.name,
                    pid = EXCLUDED.pid,
                    is_deleted = 0,
                    updated_time = NOW()
            """, (
                str(dept_id),                              # id: 用三方系统的部门ID
                dept_name,                                 # name: 组织名称
                dept_code or str(dept_id),                 # org_code: 组织编码
                TENANT_ID,                                 # tenant_id
                str(parent_id) if parent_id else ''        # pid: 根节点为空字符串
            ))

        tmp_conn.commit()
        print(f"同步组织数量: {len(orgs)}")

    finally:
        source_conn.close()
        tmp_conn.close()


# ============================================
# 同步用户
# ============================================
def sync_users():
    """同步用户"""
    source_conn = psycopg2.connect(**SOURCE_DB_CONFIG)
    tmp_conn = psycopg2.connect(**TMP_DB_CONFIG)

    try:
        source_cur = source_conn.cursor()
        tmp_cur = tmp_conn.cursor()

        # 从三方系统查询用户数据
        source_cur.execute("""
            SELECT
                user_id,           -- 用户ID
                username,          -- 用户名(登录账号)
                real_name,         -- 真实姓名
                email,
                mobile
            FROM oa_user
            WHERE status = 1
        """)

        users = source_cur.fetchall()

        for user in users:
            user_id, username, real_name, email, mobile = user

            # 插入或更新临时用户表
            tmp_cur.execute("""
                INSERT INTO tmp_user
                    (id, user_name, display_name, email, mobile,
                     tenant_id, source, status, is_deleted, updated_time)
                VALUES (%s, %s, %s, %s, %s, %s, 'CAS', 1, 0, NOW())
                ON CONFLICT (tenant_id, user_name)
                DO UPDATE SET
                    display_name = EXCLUDED.display_name,
                    email = EXCLUDED.email,
                    mobile = EXCLUDED.mobile,
                    is_deleted = 0,
                    updated_time = NOW()
            """, (
                str(user_id),      # id: 用三方系统的用户ID
                username,          # user_name: 登录用户名(唯一)
                real_name,         # display_name: 显示名称
                email or '',
                mobile or '',
                TENANT_ID
            ))

        tmp_conn.commit()
        print(f"同步用户数量: {len(users)}")

    finally:
        source_conn.close()
        tmp_conn.close()


# ============================================
# 同步用户-组织关系
# ============================================
def sync_user_org_relations():
    """同步用户-组织关系"""
    source_conn = psycopg2.connect(**SOURCE_DB_CONFIG)
    tmp_conn = psycopg2.connect(**TMP_DB_CONFIG)

    try:
        source_cur = source_conn.cursor()
        tmp_cur = tmp_conn.cursor()

        # 先清空旧的关系数据
        tmp_cur.execute(
            "DELETE FROM tmp_org_user_relation WHERE tenant_id = %s",
            (TENANT_ID,)
        )

        # 从三方系统查询用户-部门关系
        source_cur.execute("""
            SELECT
                user_id,
                dept_id
            FROM oa_user_department
        """)

        relations = source_cur.fetchall()

        for rel in relations:
            user_id, dept_id = rel

            tmp_cur.execute("""
                INSERT INTO tmp_org_user_relation
                    (id, org_id, user_id, tenant_id)
                VALUES (%s, %s, %s, %s)
            """, (
                str(uuid.uuid4()),     # id: 生成唯一ID
                str(dept_id),          # org_id: 组织ID
                str(user_id),          # user_id: 用户ID
                TENANT_ID
            ))

        tmp_conn.commit()
        print(f"同步关系数量: {len(relations)}")

    finally:
        source_conn.close()
        tmp_conn.close()


# ============================================
# 标记已删除的用户
# ============================================
def mark_deleted_users():
    """标记已删除的用户"""
    source_conn = psycopg2.connect(**SOURCE_DB_CONFIG)
    tmp_conn = psycopg2.connect(**TMP_DB_CONFIG)

    try:
        source_cur = source_conn.cursor()
        tmp_cur = tmp_conn.cursor()

        # 获取三方系统中已删除/禁用的用户
        source_cur.execute("""
            SELECT user_id FROM oa_user WHERE status = 0
        """)
        deleted_users = [str(row[0]) for row in source_cur.fetchall()]

        if deleted_users:
            tmp_cur.execute("""
                UPDATE tmp_user
                SET is_deleted = 1, updated_time = NOW()
                WHERE tenant_id = %s AND id = ANY(%s)
            """, (TENANT_ID, deleted_users))

        tmp_conn.commit()
        print(f"标记删除用户数量: {len(deleted_users)}")

    finally:
        source_conn.close()
        tmp_conn.close()


# ============================================
# 标记已删除的组织
# ============================================
def mark_deleted_organizations():
    """标记已删除的组织"""
    source_conn = psycopg2.connect(**SOURCE_DB_CONFIG)
    tmp_conn = psycopg2.connect(**TMP_DB_CONFIG)

    try:
        source_cur = source_conn.cursor()
        tmp_cur = tmp_conn.cursor()

        # 获取三方系统中已删除/禁用的组织
        source_cur.execute("""
            SELECT dept_id FROM oa_department WHERE status = 0
        """)
        deleted_orgs = [str(row[0]) for row in source_cur.fetchall()]

        if deleted_orgs:
            tmp_cur.execute("""
                UPDATE tmp_organization
                SET is_deleted = 1, updated_time = NOW()
                WHERE tenant_id = %s AND id = ANY(%s)
            """, (TENANT_ID, deleted_orgs))

        tmp_conn.commit()
        print(f"标记删除组织数量: {len(deleted_orgs)}")

    finally:
        source_conn.close()
        tmp_conn.close()


# ============================================
# 主程序入口
# ============================================
if __name__ == "__main__":
    print("=" * 50)
    print("开始同步组织架构数据到临时表")
    print("=" * 50)

    print("\n[1/5] 同步组织架构...")
    sync_organizations()

    print("\n[2/5] 同步用户...")
    sync_users()

    print("\n[3/5] 同步用户-组织关系...")
    sync_user_org_relations()

    print("\n[4/5] 标记已删除用户...")
    mark_deleted_users()

    print("\n[5/5] 标记已删除组织...")
    mark_deleted_organizations()

    print("\n" + "=" * 50)
    print("同步完成!")
    print("=" * 50)
```

---

## 5. 配置 iam-adapter

修改配置文件 `config/adapterconf/Dev.yaml`：

```yaml
Server:
  Port: 6789
  EnablePprof: false

Log:
  Level: info
  Mode: dev

# 开启组织架构同步
IsNeedSyncOrg: true

# 是否同步用户、组织ID（保持三方系统ID）
IsSyncID: true

# 是否为访客（false=普通用户）
IsVisitor: false

# 租户ID（从HiAgent环境获取）
DefaultTenant: your_tenant_id

SSO:
  HiAgentWebCallback: "http://your-hiagent-host:32300/api/auth/callback"
  HiAgentOrigin: "http://your-hiagent-host:32300"

SyncOrg:
  RootNode: ""                    # 默认为空
  SyncCronTime: "0 2 * * *"       # Cron表达式：每天凌晨2点执行同步
  SpecialHandlingNode: ""         # 默认为空

# 临时数据库配置（你申请的PG数据库）
DBConfig:
  DBType: postgresql              # 数据库类型：postgresql
  Endpoints: tmp-pg-host:5432     # 数据库地址
  User: tmp_user                  # 数据库用户名
  Password: "tmp_password"        # 数据库密码（或通过环境变量设置）
  DBName: tmp_sync_db             # 数据库名称
  ReadTimeout: "10s"
  Charset: utf8mb4
  TimeZone: UTC

# IAM服务地址
IAM:
  Host: top-server:8000
```

### 5.1 关键配置说明

| 配置项 | 说明 |
|--------|------|
| `IsNeedSyncOrg` | 设置为 `true` 开启组织架构同步 |
| `IsSyncID` | 设置为 `true` 保持三方系统的用户/组织ID |
| `DefaultTenant` | 从HiAgent环境获取的租户ID |
| `SyncCronTime` | Cron表达式，定义同步执行时间 |
| `DBConfig.DBType` | 设置为 `postgresql` |
| `DBConfig.Endpoints` | PG数据库地址和端口 |

### 5.2 Cron表达式示例

| 表达式 | 说明 |
|--------|------|
| `0 2 * * *` | 每天凌晨2点执行 |
| `0 */6 * * *` | 每6小时执行一次 |
| `*/30 * * * *` | 每30分钟执行一次 |
| `0 8,12,18 * * *` | 每天8点、12点、18点执行 |

---

## 6. 验证与同步

### 6.1 验证临时表数据

在执行同步前，先验证临时表数据是否正确：

```bash
# 进入 adapter pod 容器
kubectl exec -it <adapter-pod-name> -n <namespace> -- /bin/bash

# 调用数据验证接口
curl http://localhost:6789/CheckData
```

根据接口响应检查是否有错误，有问题需要修改临时表数据后再同步。

### 6.2 手动触发同步

验证通过后，可手动触发一次同步：

```bash
# 手动执行组织架构同步（需要在adapter容器内执行）
curl --location --request POST 'http://localhost:6789/RunJob' --data ''
```

### 6.3 查看同步结果

同步完成后，可通过以下方式验证：
- 在 HiAgent 租户管理页面 → 组织管理 中查看
- 直接查询 IAM 数据库中的用户和组织数据

---

## 7. 部署方式

### 7.1 构建镜像

```bash
# 在项目根目录执行
make build
```

### 7.2 Helm 部署

```bash
# 安装
helm install iam-adapter -n vke-system manifests/iam-adapter \
  --kubeconfig ~/.kube/{kubeconfig} --debug

# 更新
helm upgrade iam-adapter -n vke-system manifests/iam-adapter \
  --kubeconfig ~/.kube/{kubeconfig} --debug

# 删除
helm uninstall iam-adapter -n vke-system \
  --kubeconfig ~/.kube/{kubeconfig} --debug
```

---

## 8. 完整对接流程总结

| 步骤 | 负责方 | 说明 |
|------|--------|------|
| 1. 申请临时数据库 | 客户 | 申请一台PG数据库作为中间临时数据库 |
| 2. 创建临时表 | 客户 | 在PG临时数据库创建3张临时表 |
| 3. 编写同步脚本 | 客户 | 从三方OA系统读取数据写入临时表 |
| 4. 定时执行同步脚本 | 客户 | 使用cron/调度系统定期同步到临时表 |
| 5. 配置iam-adapter | 客户 | 配置临时数据库连接和同步时间 |
| 6. 部署iam-adapter | 客户 | helm部署到K8s集群 |
| 7. 验证数据 | 客户 | 调用CheckData接口验证临时表数据 |
| 8. 执行同步 | iam-adapter | 定时从临时表同步到HiAgent |

---

## 9. 常见问题

### Q1: 如何获取租户ID (tenant_id)？
从客户部署的 HiAgent 环境中获取，可在租户管理页面查看。

### Q2: 根组织的 pid 应该填什么？
根组织（最顶层组织）的 pid 填空字符串 `''`。

### Q3: 同步失败如何排查？
1. 先调用 `/CheckData` 接口验证临时表数据
2. 检查 iam-adapter 的日志
3. 确认数据库连接配置正确

### Q4: 支持哪些数据库类型？
DBConfig.DBType 支持：`mysql`、`postgresql`、`dameng`（达梦）、`kingbase`（人大金仓）

### Q5: 用户删除后如何同步？
将 `tmp_user` 表中对应用户的 `is_deleted` 字段设置为 `1`，同步任务会处理删除逻辑。

---

## 10. 联系人

如有问题，请联系：李硕
